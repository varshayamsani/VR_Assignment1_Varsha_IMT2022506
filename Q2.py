# -*- coding: utf-8 -*-
"""Q2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/134EC82mtDL_RcMC2Lq1HQIO1WK14AzY0
"""

import numpy as np
import cv2
import imutils
import os
import matplotlib.pyplot as plt

def load_images_from_folder(folder):
    files = sorted([f for f in os.listdir(folder) if f.endswith(('.png', '.jpg', '.jpeg'))])
    images = [cv2.imread(os.path.join(folder, file)) for file in files]
    return images, files

def detect_and_draw_keypoints(images, output_folder):
  # Function to detect and draw keypoints on images using ORB feature detector
    orb = cv2.ORB_create()
    for i, img in enumerate(images):
        keypoints = orb.detect(img, None)
        keypointsImage = cv2.drawKeypoints(img, keypoints, None, color=(0, 0, 255))
        cv2.imwrite(os.path.join(output_folder, f"keypoints_{i+1}.png"), keypointsImage)

        img_rgb = cv2.cvtColor(keypointsImage, cv2.COLOR_BGR2RGB)
        plt.figure(figsize=(10, 6))
        plt.imshow(img_rgb)
        plt.title(f"Keypoints in Image {i+1}")
        plt.axis("off")
        plt.show()

def stitch_images(images, output_folder):
  # Function to stitch images together
    stitcher = cv2.Stitcher_create()
    error, stitched = stitcher.stitch(images)
    if error:
        print("Error in stitching images")
        return None

    stitched_resized = cv2.resize(stitched, (6378, 2375))
    plt.figure(figsize=(10, 6))
    plt.imshow(cv2.cvtColor(stitched_resized, cv2.COLOR_BGR2RGB))
    plt.title("Stitched Resized Image")
    plt.axis("off")
    plt.show()

    cv2.imwrite(os.path.join(output_folder, "stitchedOutput.png"), stitched)
    return stitched_resized

# def process_stitched_image(stitched, output_folder):
#     stitched = cv2.copyMakeBorder(stitched, 5, 5, 5, 5, cv2.BORDER_CONSTANT, (0, 0, 0))
#     gray = cv2.cvtColor(stitched, cv2.COLOR_BGR2GRAY)
#     thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY)[1]
#     contours = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
#     contours = imutils.grab_contours(contours)
#     areaOI = max(contours, key=cv2.contourArea)
#     x, y, w, h = cv2.boundingRect(areaOI)
#     stitched_cropped = stitched[y:y + h, x:x + w]

#     plt.figure(figsize=(10, 6))
#     plt.imshow(cv2.cvtColor(stitched_cropped, cv2.COLOR_BGR2RGB))
#     plt.title("Final Stitched Image")
#     plt.axis("off")
#     plt.show()

#     cv2.imwrite(os.path.join(output_folder, "stitchedOutputProcessed.png"), stitched_cropped)
def process_stitched_image(stitched, output_folder):
  # Function to process stitched image by removing black borders
    stitched = cv2.copyMakeBorder(stitched, 5, 5, 5, 5, cv2.BORDER_CONSTANT, (0, 0, 0))
    gray = cv2.cvtColor(stitched, cv2.COLOR_BGR2GRAY)
    thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY)[1]
    thresh_copy = thresh.copy()

    contours = cv2.findContours(thresh_copy, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    contours = imutils.grab_contours(contours)
    areaOI = max(contours, key=cv2.contourArea)

    mask = np.zeros(thresh.shape, dtype="uint8")
    x, y, w, h = cv2.boundingRect(areaOI)
    cv2.rectangle(mask, (x, y), (x + w, y + h), 255, -1)

    minRectangle = mask.copy()
    sub = mask.copy()

    while cv2.countNonZero(sub) > 0:
        minRectangle = cv2.erode(minRectangle, None)
        sub = cv2.subtract(minRectangle, thresh)

    contours = cv2.findContours(minRectangle.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    contours = imutils.grab_contours(contours)
    areaOI = max(contours, key=cv2.contourArea)

    x, y, w, h = cv2.boundingRect(areaOI)
    stitched_cropped = stitched[y:y + h, x:x + w]

    plt.figure(figsize=(10, 6))
    plt.imshow(cv2.cvtColor(stitched_cropped, cv2.COLOR_BGR2RGB))
    plt.title("Final Stitched Image")
    plt.axis("off")
    plt.show()

    cv2.imwrite(os.path.join(output_folder, "stitchedOutputProcessed.png"), stitched_cropped)

def main():
    input_folder = "Question2Images"
    output_folder = "Q2outputs"
    os.makedirs(output_folder, exist_ok=True)

    images, files = load_images_from_folder(input_folder)
    detect_and_draw_keypoints(images, output_folder)

    stitched = stitch_images(images, output_folder)
    if stitched is not None:
        process_stitched_image(stitched, output_folder)

if __name__ == "__main__":
    main()